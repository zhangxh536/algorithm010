学习笔记
一、哈希表、映射、集合
1、哈希表也叫散列表，这种数据结构提供了键、值的映射关系，在不发生哈希碰撞的情况下，查询的时间复杂度为O(1);
1> 哈希碰撞
   哈希碰撞是不同的数据计算后计算出来的hash值是一样的,如果发生hash碰撞在相同位置的数据时候,通过形成一个链表的方式来解决。
   原因:函数选取不好,size不够,那么复杂度变成O(n);
2> 哈希原理
   java大部分对象都有自己的hashcode,这个hashcode是区分不同对象的重要标识,无论对象自身的类型是什么,他们的hashcode都是一个
   整型变量。
   最简单的方法就是按照数组的长度进行取模运算:index = HashCode(Key)%Array.length;
3> map、set
   map的键不能重复,值可以重复
   set里面的元素不能重复
   hashset的底层就是建了一个hashmap
4> 哈希表的实现
   java语言中,每一个对象都有属于自己的hashcode,这个hashcode是区分不同类型对象的重要标识,无论对象是什么,他们的hashcode
   是一个整型变量.
   通过hash函数形成的下标函数是有可能相同的,这就是形成哈希冲突的原因,一般解决hash冲突的方法有开放寻址法和下拉链表法.
5> 哈希表的扩容 resize
   扩容的原因:当前的散列表长度达到一定的长度后,发生hash冲突的概率会提高,对后续的操作产生较大的影响.
   这时散列表进行resize操作.
   扩容的因素: capacity,hashmap当前的长度;
              loadfactor,负载因子 默认为0.75f;
              Hashmap.size >= capacity * loadfactor的时候发生扩容 将capacity扩大为原来的2倍,然后将原来的数组内容进行
              copy.


二、树、二叉树、二叉搜索树
1、树的定义
   tree是由n(n >= 0)个节点的有限集。当n = 0时,称之为空树;在任意一个非空树有如下特点:
   1、有且仅有一个特定的称之为根的节点;
   2、当n > 1的时候,其余节点可分为m(m > 0)个互不相交的有限集,每一个集合本身又是一个树,并称之为子树;
   树的最大层称之为树的高度或者深度;
2、二叉树
1> 二叉树是树的一种特殊形式,二叉,这种树的每个节点至多拥有2个孩子节点;
   二叉树的节点一个被称为左孩子,一个为右孩子;
2> 二叉树的特殊形式
   满二叉树:
   一个二叉树的所有非叶子节点都有左右孩子,且每个叶子节点都在同一个层级,那么这个树就是满二叉树;
   完全二叉树:
   简单来说,一个满二叉树去掉最后一个层级的部分的叶子或者节点且节点按满二叉树的节点顺序为完全二叉树;
   定义:对一个n个节点的二叉树,按层级顺序编号,则所有节点的编号从1到n,如果这个树所有节点和同样深度的满二叉树的编号从1到n的
   位置相同,这个二叉树就是完全二叉树.
3> 二叉树一个逻辑结构
   可以通过
   1、数组
      特点:使用数组进行存储时,会按照层级顺序把二叉树的节点放到数组的位置上,但是一个二叉树的空节点的左孩子或者右孩子孔雀
      则对应的位置也会空出来,所以说二叉树的空缺节点越多,数组的长度就越大,浪费空间。
   2、链式存储结构即链表
      特点: 存储数据的data变量啊,左孩子指针,右孩子指针。
      公式: 父节点 * 2 + 1 = 左孩子节点;
            父节点 * 2 + 2 = 右孩子节点;
            反之可通过孩子节点求父亲节点。
   3、简单的树
      public class TreeNode {
        public int val;
        public TreeNode left;//左孩子
        public TreeNode right;//右孩子
        public TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
      }
4、二叉树的遍历
   1> 前序遍历 
   2> 中序遍历
   3> 后序遍历
   为什么要进行遍历: 由于底层是数组或者链表构成的,如果树是无序的,那么在查找某个元素的时候就必须遍历每个节点。
   
5、二叉树的应用: 二叉搜索树、红黑树、AVL树、树堆等
   二叉搜索树也叫二叉查找树,二叉排序树
   特征:  1、所有的左节点小于根节点
         2、所有的右节点大于根节点
         3、所有的子树亦然
         空树也是一个二叉查找树
         二叉查找树是中序遍历,是升序遍历。
    时间复杂度:
         O(logn)
         删除节点,取第一个大于要删除的节点的节点进行替换。
         
三、堆和二叉堆、图
    1、堆:heap
    heap可以迅速找到一堆数中最大或者最小值的数据结构
    分别为大顶堆或者大根堆和小顶堆或者小根堆;
    最大堆:任何一个父节点都大于或者等于它的左孩子、右孩子节点的值.
    最小堆:任何一个父节点都小于或者等于它的左孩子、右孩子节点的值.
    2、二叉堆
    通过完全二叉树来实现,可以实现自我调整;
    插入节点是自下向上的调整,heapifyup;插入数组末尾size++;
    删除节点是自上向下的调整,heapifydown;替换第一个元素的值,size--;
    二叉堆的实现方式非链表存储,而是由数组形成的。
    3、图
    有点有边的结构称之为图,
    V-Vertex, E-Edge
    图分为四种
    1> 无向无权图;
    2> 无向有权图;
    3> 有向有权图;
    4> 有向无权图;
    其中有向为两个节点有对应的方向,权指的是权重即边长。
    图的dfs 与树的dfs区别: visited = set();即去重,图的访问有可能重复访问节点。
    
   
   
   